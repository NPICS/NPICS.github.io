/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  BaseContract,
  BigNumber,
  BigNumberish,
  BytesLike,
  CallOverrides,
  ContractTransaction,
  Overrides,
  PopulatedTransaction,
  Signer,
  utils,
} from "ethers";
import type {
  FunctionFragment,
  Result,
  EventFragment,
} from "@ethersproject/abi";
import type { Listener, Provider } from "@ethersproject/providers";
import type {
  TypedEventFilter,
  TypedEvent,
  TypedListener,
  OnEvent,
  PromiseOrValue,
} from "./common";

export declare namespace DataTypes {
  export type NftConfigurationMapStruct = {
    data: PromiseOrValue<BigNumberish>;
  };

  export type NftConfigurationMapStructOutput = [BigNumber] & {
    data: BigNumber;
  };

  export type NftDataStruct = {
    configuration: DataTypes.NftConfigurationMapStruct;
    bNftAddress: PromiseOrValue<string>;
    id: PromiseOrValue<BigNumberish>;
  };

  export type NftDataStructOutput = [
    DataTypes.NftConfigurationMapStructOutput,
    string,
    number
  ] & {
    configuration: DataTypes.NftConfigurationMapStructOutput;
    bNftAddress: string;
    id: number;
  };

  export type ReserveConfigurationMapStruct = {
    data: PromiseOrValue<BigNumberish>;
  };

  export type ReserveConfigurationMapStructOutput = [BigNumber] & {
    data: BigNumber;
  };

  export type ReserveDataStruct = {
    configuration: DataTypes.ReserveConfigurationMapStruct;
    liquidityIndex: PromiseOrValue<BigNumberish>;
    variableBorrowIndex: PromiseOrValue<BigNumberish>;
    currentLiquidityRate: PromiseOrValue<BigNumberish>;
    currentVariableBorrowRate: PromiseOrValue<BigNumberish>;
    lastUpdateTimestamp: PromiseOrValue<BigNumberish>;
    bTokenAddress: PromiseOrValue<string>;
    debtTokenAddress: PromiseOrValue<string>;
    interestRateAddress: PromiseOrValue<string>;
    id: PromiseOrValue<BigNumberish>;
  };

  export type ReserveDataStructOutput = [
    DataTypes.ReserveConfigurationMapStructOutput,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    number,
    string,
    string,
    string,
    number
  ] & {
    configuration: DataTypes.ReserveConfigurationMapStructOutput;
    liquidityIndex: BigNumber;
    variableBorrowIndex: BigNumber;
    currentLiquidityRate: BigNumber;
    currentVariableBorrowRate: BigNumber;
    lastUpdateTimestamp: number;
    bTokenAddress: string;
    debtTokenAddress: string;
    interestRateAddress: string;
    id: number;
  };
}

export interface LendPoolInterface extends utils.Interface {
  functions: {
    "auction(address,uint256,uint256,address)": FunctionFragment;
    "batchBorrow(address[],uint256[],address[],uint256[],address,uint16)": FunctionFragment;
    "batchRepay(address[],uint256[],uint256[])": FunctionFragment;
    "borrow(address,uint256,address,uint256,address,uint16)": FunctionFragment;
    "deposit(address,uint256,address,uint16)": FunctionFragment;
    "finalizeTransfer(address,address,address,uint256,uint256,uint256)": FunctionFragment;
    "getAddressesProvider()": FunctionFragment;
    "getMaxNumberOfNfts()": FunctionFragment;
    "getMaxNumberOfReserves()": FunctionFragment;
    "getNftAuctionData(address,uint256)": FunctionFragment;
    "getNftCollateralData(address,address)": FunctionFragment;
    "getNftConfiguration(address)": FunctionFragment;
    "getNftData(address)": FunctionFragment;
    "getNftDebtData(address,uint256)": FunctionFragment;
    "getNftLiquidatePrice(address,uint256)": FunctionFragment;
    "getNftsList()": FunctionFragment;
    "getReserveConfiguration(address)": FunctionFragment;
    "getReserveData(address)": FunctionFragment;
    "getReserveNormalizedIncome(address)": FunctionFragment;
    "getReserveNormalizedVariableDebt(address)": FunctionFragment;
    "getReservesList()": FunctionFragment;
    "initNft(address,address)": FunctionFragment;
    "initReserve(address,address,address,address)": FunctionFragment;
    "initialize(address)": FunctionFragment;
    "liquidate(address,uint256,uint256)": FunctionFragment;
    "onERC721Received(address,address,uint256,bytes)": FunctionFragment;
    "paused()": FunctionFragment;
    "redeem(address,uint256,uint256,uint256)": FunctionFragment;
    "repay(address,uint256,uint256)": FunctionFragment;
    "setMaxNumberOfNfts(uint256)": FunctionFragment;
    "setMaxNumberOfReserves(uint256)": FunctionFragment;
    "setNftConfiguration(address,uint256)": FunctionFragment;
    "setPause(bool)": FunctionFragment;
    "setReserveConfiguration(address,uint256)": FunctionFragment;
    "setReserveInterestRateAddress(address,address)": FunctionFragment;
    "withdraw(address,uint256,address)": FunctionFragment;
  };

  getFunction(
    nameOrSignatureOrTopic:
      | "auction"
      | "batchBorrow"
      | "batchRepay"
      | "borrow"
      | "deposit"
      | "finalizeTransfer"
      | "getAddressesProvider"
      | "getMaxNumberOfNfts"
      | "getMaxNumberOfReserves"
      | "getNftAuctionData"
      | "getNftCollateralData"
      | "getNftConfiguration"
      | "getNftData"
      | "getNftDebtData"
      | "getNftLiquidatePrice"
      | "getNftsList"
      | "getReserveConfiguration"
      | "getReserveData"
      | "getReserveNormalizedIncome"
      | "getReserveNormalizedVariableDebt"
      | "getReservesList"
      | "initNft"
      | "initReserve"
      | "initialize"
      | "liquidate"
      | "onERC721Received"
      | "paused"
      | "redeem"
      | "repay"
      | "setMaxNumberOfNfts"
      | "setMaxNumberOfReserves"
      | "setNftConfiguration"
      | "setPause"
      | "setReserveConfiguration"
      | "setReserveInterestRateAddress"
      | "withdraw"
  ): FunctionFragment;

  encodeFunctionData(
    functionFragment: "auction",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<string>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "batchBorrow",
    values: [
      PromiseOrValue<string>[],
      PromiseOrValue<BigNumberish>[],
      PromiseOrValue<string>[],
      PromiseOrValue<BigNumberish>[],
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "batchRepay",
    values: [
      PromiseOrValue<string>[],
      PromiseOrValue<BigNumberish>[],
      PromiseOrValue<BigNumberish>[]
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "borrow",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "deposit",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "finalizeTransfer",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "getAddressesProvider",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "getMaxNumberOfNfts",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "getMaxNumberOfReserves",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "getNftAuctionData",
    values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "getNftCollateralData",
    values: [PromiseOrValue<string>, PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "getNftConfiguration",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "getNftData",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "getNftDebtData",
    values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "getNftLiquidatePrice",
    values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "getNftsList",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "getReserveConfiguration",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "getReserveData",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "getReserveNormalizedIncome",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "getReserveNormalizedVariableDebt",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "getReservesList",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "initNft",
    values: [PromiseOrValue<string>, PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "initReserve",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<string>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "initialize",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "liquidate",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "onERC721Received",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BytesLike>
    ]
  ): string;
  encodeFunctionData(functionFragment: "paused", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "redeem",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "repay",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "setMaxNumberOfNfts",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "setMaxNumberOfReserves",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "setNftConfiguration",
    values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "setPause",
    values: [PromiseOrValue<boolean>]
  ): string;
  encodeFunctionData(
    functionFragment: "setReserveConfiguration",
    values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "setReserveInterestRateAddress",
    values: [PromiseOrValue<string>, PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "withdraw",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<string>
    ]
  ): string;

  decodeFunctionResult(functionFragment: "auction", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "batchBorrow",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "batchRepay", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "borrow", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "deposit", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "finalizeTransfer",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getAddressesProvider",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getMaxNumberOfNfts",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getMaxNumberOfReserves",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getNftAuctionData",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getNftCollateralData",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getNftConfiguration",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "getNftData", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "getNftDebtData",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getNftLiquidatePrice",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getNftsList",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getReserveConfiguration",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getReserveData",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getReserveNormalizedIncome",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getReserveNormalizedVariableDebt",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getReservesList",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "initNft", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "initReserve",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "initialize", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "liquidate", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "onERC721Received",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "paused", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "redeem", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "repay", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "setMaxNumberOfNfts",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setMaxNumberOfReserves",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setNftConfiguration",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "setPause", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "setReserveConfiguration",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setReserveInterestRateAddress",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "withdraw", data: BytesLike): Result;

  events: {
    "Auction(address,address,uint256,address,uint256,address,address,uint256)": EventFragment;
    "Borrow(address,address,uint256,address,uint256,address,uint256,uint256,uint16)": EventFragment;
    "Deposit(address,address,uint256,address,uint16)": EventFragment;
    "Liquidate(address,address,uint256,uint256,address,uint256,address,uint256)": EventFragment;
    "Paused()": EventFragment;
    "Redeem(address,address,uint256,uint256,address,uint256,address,uint256)": EventFragment;
    "Repay(address,address,uint256,address,uint256,address,uint256)": EventFragment;
    "ReserveDataUpdated(address,uint256,uint256,uint256,uint256)": EventFragment;
    "Unpaused()": EventFragment;
    "Withdraw(address,address,uint256,address)": EventFragment;
  };

  getEvent(nameOrSignatureOrTopic: "Auction"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "Borrow"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "Deposit"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "Liquidate"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "Paused"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "Redeem"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "Repay"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "ReserveDataUpdated"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "Unpaused"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "Withdraw"): EventFragment;
}

export interface AuctionEventObject {
  user: string;
  reserve: string;
  bidPrice: BigNumber;
  nftAsset: string;
  nftTokenId: BigNumber;
  onBehalfOf: string;
  borrower: string;
  loanId: BigNumber;
}
export type AuctionEvent = TypedEvent<
  [string, string, BigNumber, string, BigNumber, string, string, BigNumber],
  AuctionEventObject
>;

export type AuctionEventFilter = TypedEventFilter<AuctionEvent>;

export interface BorrowEventObject {
  user: string;
  reserve: string;
  amount: BigNumber;
  nftAsset: string;
  nftTokenId: BigNumber;
  onBehalfOf: string;
  borrowRate: BigNumber;
  loanId: BigNumber;
  referral: number;
}
export type BorrowEvent = TypedEvent<
  [
    string,
    string,
    BigNumber,
    string,
    BigNumber,
    string,
    BigNumber,
    BigNumber,
    number
  ],
  BorrowEventObject
>;

export type BorrowEventFilter = TypedEventFilter<BorrowEvent>;

export interface DepositEventObject {
  user: string;
  reserve: string;
  amount: BigNumber;
  onBehalfOf: string;
  referral: number;
}
export type DepositEvent = TypedEvent<
  [string, string, BigNumber, string, number],
  DepositEventObject
>;

export type DepositEventFilter = TypedEventFilter<DepositEvent>;

export interface LiquidateEventObject {
  user: string;
  reserve: string;
  repayAmount: BigNumber;
  remainAmount: BigNumber;
  nftAsset: string;
  nftTokenId: BigNumber;
  borrower: string;
  loanId: BigNumber;
}
export type LiquidateEvent = TypedEvent<
  [string, string, BigNumber, BigNumber, string, BigNumber, string, BigNumber],
  LiquidateEventObject
>;

export type LiquidateEventFilter = TypedEventFilter<LiquidateEvent>;

export interface PausedEventObject {}
export type PausedEvent = TypedEvent<[], PausedEventObject>;

export type PausedEventFilter = TypedEventFilter<PausedEvent>;

export interface RedeemEventObject {
  user: string;
  reserve: string;
  borrowAmount: BigNumber;
  fineAmount: BigNumber;
  nftAsset: string;
  nftTokenId: BigNumber;
  borrower: string;
  loanId: BigNumber;
}
export type RedeemEvent = TypedEvent<
  [string, string, BigNumber, BigNumber, string, BigNumber, string, BigNumber],
  RedeemEventObject
>;

export type RedeemEventFilter = TypedEventFilter<RedeemEvent>;

export interface RepayEventObject {
  user: string;
  reserve: string;
  amount: BigNumber;
  nftAsset: string;
  nftTokenId: BigNumber;
  borrower: string;
  loanId: BigNumber;
}
export type RepayEvent = TypedEvent<
  [string, string, BigNumber, string, BigNumber, string, BigNumber],
  RepayEventObject
>;

export type RepayEventFilter = TypedEventFilter<RepayEvent>;

export interface ReserveDataUpdatedEventObject {
  reserve: string;
  liquidityRate: BigNumber;
  variableBorrowRate: BigNumber;
  liquidityIndex: BigNumber;
  variableBorrowIndex: BigNumber;
}
export type ReserveDataUpdatedEvent = TypedEvent<
  [string, BigNumber, BigNumber, BigNumber, BigNumber],
  ReserveDataUpdatedEventObject
>;

export type ReserveDataUpdatedEventFilter =
  TypedEventFilter<ReserveDataUpdatedEvent>;

export interface UnpausedEventObject {}
export type UnpausedEvent = TypedEvent<[], UnpausedEventObject>;

export type UnpausedEventFilter = TypedEventFilter<UnpausedEvent>;

export interface WithdrawEventObject {
  user: string;
  reserve: string;
  amount: BigNumber;
  to: string;
}
export type WithdrawEvent = TypedEvent<
  [string, string, BigNumber, string],
  WithdrawEventObject
>;

export type WithdrawEventFilter = TypedEventFilter<WithdrawEvent>;

export interface LendPool extends BaseContract {
  connect(signerOrProvider: Signer | Provider | string): this;
  attach(addressOrName: string): this;
  deployed(): Promise<this>;

  interface: LendPoolInterface;

  queryFilter<TEvent extends TypedEvent>(
    event: TypedEventFilter<TEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TEvent>>;

  listeners<TEvent extends TypedEvent>(
    eventFilter?: TypedEventFilter<TEvent>
  ): Array<TypedListener<TEvent>>;
  listeners(eventName?: string): Array<Listener>;
  removeAllListeners<TEvent extends TypedEvent>(
    eventFilter: TypedEventFilter<TEvent>
  ): this;
  removeAllListeners(eventName?: string): this;
  off: OnEvent<this>;
  on: OnEvent<this>;
  once: OnEvent<this>;
  removeListener: OnEvent<this>;

  functions: {
    auction(
      nftAsset: PromiseOrValue<string>,
      nftTokenId: PromiseOrValue<BigNumberish>,
      bidPrice: PromiseOrValue<BigNumberish>,
      onBehalfOf: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    batchBorrow(
      assets: PromiseOrValue<string>[],
      amounts: PromiseOrValue<BigNumberish>[],
      nftAssets: PromiseOrValue<string>[],
      nftTokenIds: PromiseOrValue<BigNumberish>[],
      onBehalfOf: PromiseOrValue<string>,
      referralCode: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    batchRepay(
      nftAssets: PromiseOrValue<string>[],
      nftTokenIds: PromiseOrValue<BigNumberish>[],
      amounts: PromiseOrValue<BigNumberish>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    borrow(
      asset: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      nftAsset: PromiseOrValue<string>,
      nftTokenId: PromiseOrValue<BigNumberish>,
      onBehalfOf: PromiseOrValue<string>,
      referralCode: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    deposit(
      asset: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      onBehalfOf: PromiseOrValue<string>,
      referralCode: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    finalizeTransfer(
      asset: PromiseOrValue<string>,
      from: PromiseOrValue<string>,
      to: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      balanceFromBefore: PromiseOrValue<BigNumberish>,
      balanceToBefore: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[void]>;

    getAddressesProvider(overrides?: CallOverrides): Promise<[string]>;

    getMaxNumberOfNfts(overrides?: CallOverrides): Promise<[BigNumber]>;

    getMaxNumberOfReserves(overrides?: CallOverrides): Promise<[BigNumber]>;

    getNftAuctionData(
      nftAsset: PromiseOrValue<string>,
      nftTokenId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, string, BigNumber, BigNumber, BigNumber] & {
        loanId: BigNumber;
        bidderAddress: string;
        bidPrice: BigNumber;
        bidBorrowAmount: BigNumber;
        bidFine: BigNumber;
      }
    >;

    getNftCollateralData(
      nftAsset: PromiseOrValue<string>,
      reserveAsset: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<
      [
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber
      ] & {
        totalCollateralInETH: BigNumber;
        totalCollateralInReserve: BigNumber;
        availableBorrowsInETH: BigNumber;
        availableBorrowsInReserve: BigNumber;
        ltv: BigNumber;
        liquidationThreshold: BigNumber;
        liquidationBonus: BigNumber;
      }
    >;

    getNftConfiguration(
      asset: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[DataTypes.NftConfigurationMapStructOutput]>;

    getNftData(
      asset: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[DataTypes.NftDataStructOutput]>;

    getNftDebtData(
      nftAsset: PromiseOrValue<string>,
      nftTokenId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, string, BigNumber, BigNumber, BigNumber, BigNumber] & {
        loanId: BigNumber;
        reserveAsset: string;
        totalCollateral: BigNumber;
        totalDebt: BigNumber;
        availableBorrows: BigNumber;
        healthFactor: BigNumber;
      }
    >;

    getNftLiquidatePrice(
      nftAsset: PromiseOrValue<string>,
      nftTokenId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber] & {
        liquidatePrice: BigNumber;
        paybackAmount: BigNumber;
      }
    >;

    getNftsList(overrides?: CallOverrides): Promise<[string[]]>;

    getReserveConfiguration(
      asset: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[DataTypes.ReserveConfigurationMapStructOutput]>;

    getReserveData(
      asset: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[DataTypes.ReserveDataStructOutput]>;

    getReserveNormalizedIncome(
      asset: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    getReserveNormalizedVariableDebt(
      asset: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    getReservesList(overrides?: CallOverrides): Promise<[string[]]>;

    initNft(
      asset: PromiseOrValue<string>,
      bNftAddress: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    initReserve(
      asset: PromiseOrValue<string>,
      bTokenAddress: PromiseOrValue<string>,
      debtTokenAddress: PromiseOrValue<string>,
      interestRateAddress: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    initialize(
      provider: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    liquidate(
      nftAsset: PromiseOrValue<string>,
      nftTokenId: PromiseOrValue<BigNumberish>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    onERC721Received(
      operator: PromiseOrValue<string>,
      from: PromiseOrValue<string>,
      tokenId: PromiseOrValue<BigNumberish>,
      data: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<[string]>;

    paused(overrides?: CallOverrides): Promise<[boolean]>;

    redeem(
      nftAsset: PromiseOrValue<string>,
      nftTokenId: PromiseOrValue<BigNumberish>,
      amount: PromiseOrValue<BigNumberish>,
      bidFine: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    repay(
      nftAsset: PromiseOrValue<string>,
      nftTokenId: PromiseOrValue<BigNumberish>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    setMaxNumberOfNfts(
      val: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    setMaxNumberOfReserves(
      val: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    setNftConfiguration(
      asset: PromiseOrValue<string>,
      configuration: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    setPause(
      val: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    setReserveConfiguration(
      asset: PromiseOrValue<string>,
      configuration: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    setReserveInterestRateAddress(
      asset: PromiseOrValue<string>,
      rateAddress: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    withdraw(
      asset: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      to: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;
  };

  auction(
    nftAsset: PromiseOrValue<string>,
    nftTokenId: PromiseOrValue<BigNumberish>,
    bidPrice: PromiseOrValue<BigNumberish>,
    onBehalfOf: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  batchBorrow(
    assets: PromiseOrValue<string>[],
    amounts: PromiseOrValue<BigNumberish>[],
    nftAssets: PromiseOrValue<string>[],
    nftTokenIds: PromiseOrValue<BigNumberish>[],
    onBehalfOf: PromiseOrValue<string>,
    referralCode: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  batchRepay(
    nftAssets: PromiseOrValue<string>[],
    nftTokenIds: PromiseOrValue<BigNumberish>[],
    amounts: PromiseOrValue<BigNumberish>[],
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  borrow(
    asset: PromiseOrValue<string>,
    amount: PromiseOrValue<BigNumberish>,
    nftAsset: PromiseOrValue<string>,
    nftTokenId: PromiseOrValue<BigNumberish>,
    onBehalfOf: PromiseOrValue<string>,
    referralCode: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  deposit(
    asset: PromiseOrValue<string>,
    amount: PromiseOrValue<BigNumberish>,
    onBehalfOf: PromiseOrValue<string>,
    referralCode: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  finalizeTransfer(
    asset: PromiseOrValue<string>,
    from: PromiseOrValue<string>,
    to: PromiseOrValue<string>,
    amount: PromiseOrValue<BigNumberish>,
    balanceFromBefore: PromiseOrValue<BigNumberish>,
    balanceToBefore: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<void>;

  getAddressesProvider(overrides?: CallOverrides): Promise<string>;

  getMaxNumberOfNfts(overrides?: CallOverrides): Promise<BigNumber>;

  getMaxNumberOfReserves(overrides?: CallOverrides): Promise<BigNumber>;

  getNftAuctionData(
    nftAsset: PromiseOrValue<string>,
    nftTokenId: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<
    [BigNumber, string, BigNumber, BigNumber, BigNumber] & {
      loanId: BigNumber;
      bidderAddress: string;
      bidPrice: BigNumber;
      bidBorrowAmount: BigNumber;
      bidFine: BigNumber;
    }
  >;

  getNftCollateralData(
    nftAsset: PromiseOrValue<string>,
    reserveAsset: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<
    [
      BigNumber,
      BigNumber,
      BigNumber,
      BigNumber,
      BigNumber,
      BigNumber,
      BigNumber
    ] & {
      totalCollateralInETH: BigNumber;
      totalCollateralInReserve: BigNumber;
      availableBorrowsInETH: BigNumber;
      availableBorrowsInReserve: BigNumber;
      ltv: BigNumber;
      liquidationThreshold: BigNumber;
      liquidationBonus: BigNumber;
    }
  >;

  getNftConfiguration(
    asset: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<DataTypes.NftConfigurationMapStructOutput>;

  getNftData(
    asset: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<DataTypes.NftDataStructOutput>;

  getNftDebtData(
    nftAsset: PromiseOrValue<string>,
    nftTokenId: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<
    [BigNumber, string, BigNumber, BigNumber, BigNumber, BigNumber] & {
      loanId: BigNumber;
      reserveAsset: string;
      totalCollateral: BigNumber;
      totalDebt: BigNumber;
      availableBorrows: BigNumber;
      healthFactor: BigNumber;
    }
  >;

  getNftLiquidatePrice(
    nftAsset: PromiseOrValue<string>,
    nftTokenId: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<
    [BigNumber, BigNumber] & {
      liquidatePrice: BigNumber;
      paybackAmount: BigNumber;
    }
  >;

  getNftsList(overrides?: CallOverrides): Promise<string[]>;

  getReserveConfiguration(
    asset: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<DataTypes.ReserveConfigurationMapStructOutput>;

  getReserveData(
    asset: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<DataTypes.ReserveDataStructOutput>;

  getReserveNormalizedIncome(
    asset: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  getReserveNormalizedVariableDebt(
    asset: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  getReservesList(overrides?: CallOverrides): Promise<string[]>;

  initNft(
    asset: PromiseOrValue<string>,
    bNftAddress: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  initReserve(
    asset: PromiseOrValue<string>,
    bTokenAddress: PromiseOrValue<string>,
    debtTokenAddress: PromiseOrValue<string>,
    interestRateAddress: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  initialize(
    provider: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  liquidate(
    nftAsset: PromiseOrValue<string>,
    nftTokenId: PromiseOrValue<BigNumberish>,
    amount: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  onERC721Received(
    operator: PromiseOrValue<string>,
    from: PromiseOrValue<string>,
    tokenId: PromiseOrValue<BigNumberish>,
    data: PromiseOrValue<BytesLike>,
    overrides?: CallOverrides
  ): Promise<string>;

  paused(overrides?: CallOverrides): Promise<boolean>;

  redeem(
    nftAsset: PromiseOrValue<string>,
    nftTokenId: PromiseOrValue<BigNumberish>,
    amount: PromiseOrValue<BigNumberish>,
    bidFine: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  repay(
    nftAsset: PromiseOrValue<string>,
    nftTokenId: PromiseOrValue<BigNumberish>,
    amount: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  setMaxNumberOfNfts(
    val: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  setMaxNumberOfReserves(
    val: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  setNftConfiguration(
    asset: PromiseOrValue<string>,
    configuration: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  setPause(
    val: PromiseOrValue<boolean>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  setReserveConfiguration(
    asset: PromiseOrValue<string>,
    configuration: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  setReserveInterestRateAddress(
    asset: PromiseOrValue<string>,
    rateAddress: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  withdraw(
    asset: PromiseOrValue<string>,
    amount: PromiseOrValue<BigNumberish>,
    to: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  callStatic: {
    auction(
      nftAsset: PromiseOrValue<string>,
      nftTokenId: PromiseOrValue<BigNumberish>,
      bidPrice: PromiseOrValue<BigNumberish>,
      onBehalfOf: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    batchBorrow(
      assets: PromiseOrValue<string>[],
      amounts: PromiseOrValue<BigNumberish>[],
      nftAssets: PromiseOrValue<string>[],
      nftTokenIds: PromiseOrValue<BigNumberish>[],
      onBehalfOf: PromiseOrValue<string>,
      referralCode: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    batchRepay(
      nftAssets: PromiseOrValue<string>[],
      nftTokenIds: PromiseOrValue<BigNumberish>[],
      amounts: PromiseOrValue<BigNumberish>[],
      overrides?: CallOverrides
    ): Promise<[BigNumber[], boolean[]]>;

    borrow(
      asset: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      nftAsset: PromiseOrValue<string>,
      nftTokenId: PromiseOrValue<BigNumberish>,
      onBehalfOf: PromiseOrValue<string>,
      referralCode: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    deposit(
      asset: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      onBehalfOf: PromiseOrValue<string>,
      referralCode: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    finalizeTransfer(
      asset: PromiseOrValue<string>,
      from: PromiseOrValue<string>,
      to: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      balanceFromBefore: PromiseOrValue<BigNumberish>,
      balanceToBefore: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    getAddressesProvider(overrides?: CallOverrides): Promise<string>;

    getMaxNumberOfNfts(overrides?: CallOverrides): Promise<BigNumber>;

    getMaxNumberOfReserves(overrides?: CallOverrides): Promise<BigNumber>;

    getNftAuctionData(
      nftAsset: PromiseOrValue<string>,
      nftTokenId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, string, BigNumber, BigNumber, BigNumber] & {
        loanId: BigNumber;
        bidderAddress: string;
        bidPrice: BigNumber;
        bidBorrowAmount: BigNumber;
        bidFine: BigNumber;
      }
    >;

    getNftCollateralData(
      nftAsset: PromiseOrValue<string>,
      reserveAsset: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<
      [
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber
      ] & {
        totalCollateralInETH: BigNumber;
        totalCollateralInReserve: BigNumber;
        availableBorrowsInETH: BigNumber;
        availableBorrowsInReserve: BigNumber;
        ltv: BigNumber;
        liquidationThreshold: BigNumber;
        liquidationBonus: BigNumber;
      }
    >;

    getNftConfiguration(
      asset: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<DataTypes.NftConfigurationMapStructOutput>;

    getNftData(
      asset: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<DataTypes.NftDataStructOutput>;

    getNftDebtData(
      nftAsset: PromiseOrValue<string>,
      nftTokenId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, string, BigNumber, BigNumber, BigNumber, BigNumber] & {
        loanId: BigNumber;
        reserveAsset: string;
        totalCollateral: BigNumber;
        totalDebt: BigNumber;
        availableBorrows: BigNumber;
        healthFactor: BigNumber;
      }
    >;

    getNftLiquidatePrice(
      nftAsset: PromiseOrValue<string>,
      nftTokenId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber] & {
        liquidatePrice: BigNumber;
        paybackAmount: BigNumber;
      }
    >;

    getNftsList(overrides?: CallOverrides): Promise<string[]>;

    getReserveConfiguration(
      asset: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<DataTypes.ReserveConfigurationMapStructOutput>;

    getReserveData(
      asset: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<DataTypes.ReserveDataStructOutput>;

    getReserveNormalizedIncome(
      asset: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getReserveNormalizedVariableDebt(
      asset: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getReservesList(overrides?: CallOverrides): Promise<string[]>;

    initNft(
      asset: PromiseOrValue<string>,
      bNftAddress: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    initReserve(
      asset: PromiseOrValue<string>,
      bTokenAddress: PromiseOrValue<string>,
      debtTokenAddress: PromiseOrValue<string>,
      interestRateAddress: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    initialize(
      provider: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    liquidate(
      nftAsset: PromiseOrValue<string>,
      nftTokenId: PromiseOrValue<BigNumberish>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    onERC721Received(
      operator: PromiseOrValue<string>,
      from: PromiseOrValue<string>,
      tokenId: PromiseOrValue<BigNumberish>,
      data: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<string>;

    paused(overrides?: CallOverrides): Promise<boolean>;

    redeem(
      nftAsset: PromiseOrValue<string>,
      nftTokenId: PromiseOrValue<BigNumberish>,
      amount: PromiseOrValue<BigNumberish>,
      bidFine: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    repay(
      nftAsset: PromiseOrValue<string>,
      nftTokenId: PromiseOrValue<BigNumberish>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[BigNumber, boolean]>;

    setMaxNumberOfNfts(
      val: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    setMaxNumberOfReserves(
      val: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    setNftConfiguration(
      asset: PromiseOrValue<string>,
      configuration: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    setPause(
      val: PromiseOrValue<boolean>,
      overrides?: CallOverrides
    ): Promise<void>;

    setReserveConfiguration(
      asset: PromiseOrValue<string>,
      configuration: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    setReserveInterestRateAddress(
      asset: PromiseOrValue<string>,
      rateAddress: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    withdraw(
      asset: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      to: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;
  };

  filters: {
    "Auction(address,address,uint256,address,uint256,address,address,uint256)"(
      user?: null,
      reserve?: PromiseOrValue<string> | null,
      bidPrice?: null,
      nftAsset?: PromiseOrValue<string> | null,
      nftTokenId?: null,
      onBehalfOf?: null,
      borrower?: PromiseOrValue<string> | null,
      loanId?: null
    ): AuctionEventFilter;
    Auction(
      user?: null,
      reserve?: PromiseOrValue<string> | null,
      bidPrice?: null,
      nftAsset?: PromiseOrValue<string> | null,
      nftTokenId?: null,
      onBehalfOf?: null,
      borrower?: PromiseOrValue<string> | null,
      loanId?: null
    ): AuctionEventFilter;

    "Borrow(address,address,uint256,address,uint256,address,uint256,uint256,uint16)"(
      user?: null,
      reserve?: PromiseOrValue<string> | null,
      amount?: null,
      nftAsset?: null,
      nftTokenId?: null,
      onBehalfOf?: PromiseOrValue<string> | null,
      borrowRate?: null,
      loanId?: null,
      referral?: PromiseOrValue<BigNumberish> | null
    ): BorrowEventFilter;
    Borrow(
      user?: null,
      reserve?: PromiseOrValue<string> | null,
      amount?: null,
      nftAsset?: null,
      nftTokenId?: null,
      onBehalfOf?: PromiseOrValue<string> | null,
      borrowRate?: null,
      loanId?: null,
      referral?: PromiseOrValue<BigNumberish> | null
    ): BorrowEventFilter;

    "Deposit(address,address,uint256,address,uint16)"(
      user?: null,
      reserve?: PromiseOrValue<string> | null,
      amount?: null,
      onBehalfOf?: PromiseOrValue<string> | null,
      referral?: PromiseOrValue<BigNumberish> | null
    ): DepositEventFilter;
    Deposit(
      user?: null,
      reserve?: PromiseOrValue<string> | null,
      amount?: null,
      onBehalfOf?: PromiseOrValue<string> | null,
      referral?: PromiseOrValue<BigNumberish> | null
    ): DepositEventFilter;

    "Liquidate(address,address,uint256,uint256,address,uint256,address,uint256)"(
      user?: null,
      reserve?: PromiseOrValue<string> | null,
      repayAmount?: null,
      remainAmount?: null,
      nftAsset?: PromiseOrValue<string> | null,
      nftTokenId?: null,
      borrower?: PromiseOrValue<string> | null,
      loanId?: null
    ): LiquidateEventFilter;
    Liquidate(
      user?: null,
      reserve?: PromiseOrValue<string> | null,
      repayAmount?: null,
      remainAmount?: null,
      nftAsset?: PromiseOrValue<string> | null,
      nftTokenId?: null,
      borrower?: PromiseOrValue<string> | null,
      loanId?: null
    ): LiquidateEventFilter;

    "Paused()"(): PausedEventFilter;
    Paused(): PausedEventFilter;

    "Redeem(address,address,uint256,uint256,address,uint256,address,uint256)"(
      user?: null,
      reserve?: PromiseOrValue<string> | null,
      borrowAmount?: null,
      fineAmount?: null,
      nftAsset?: PromiseOrValue<string> | null,
      nftTokenId?: null,
      borrower?: PromiseOrValue<string> | null,
      loanId?: null
    ): RedeemEventFilter;
    Redeem(
      user?: null,
      reserve?: PromiseOrValue<string> | null,
      borrowAmount?: null,
      fineAmount?: null,
      nftAsset?: PromiseOrValue<string> | null,
      nftTokenId?: null,
      borrower?: PromiseOrValue<string> | null,
      loanId?: null
    ): RedeemEventFilter;

    "Repay(address,address,uint256,address,uint256,address,uint256)"(
      user?: null,
      reserve?: PromiseOrValue<string> | null,
      amount?: null,
      nftAsset?: PromiseOrValue<string> | null,
      nftTokenId?: null,
      borrower?: PromiseOrValue<string> | null,
      loanId?: null
    ): RepayEventFilter;
    Repay(
      user?: null,
      reserve?: PromiseOrValue<string> | null,
      amount?: null,
      nftAsset?: PromiseOrValue<string> | null,
      nftTokenId?: null,
      borrower?: PromiseOrValue<string> | null,
      loanId?: null
    ): RepayEventFilter;

    "ReserveDataUpdated(address,uint256,uint256,uint256,uint256)"(
      reserve?: PromiseOrValue<string> | null,
      liquidityRate?: null,
      variableBorrowRate?: null,
      liquidityIndex?: null,
      variableBorrowIndex?: null
    ): ReserveDataUpdatedEventFilter;
    ReserveDataUpdated(
      reserve?: PromiseOrValue<string> | null,
      liquidityRate?: null,
      variableBorrowRate?: null,
      liquidityIndex?: null,
      variableBorrowIndex?: null
    ): ReserveDataUpdatedEventFilter;

    "Unpaused()"(): UnpausedEventFilter;
    Unpaused(): UnpausedEventFilter;

    "Withdraw(address,address,uint256,address)"(
      user?: PromiseOrValue<string> | null,
      reserve?: PromiseOrValue<string> | null,
      amount?: null,
      to?: PromiseOrValue<string> | null
    ): WithdrawEventFilter;
    Withdraw(
      user?: PromiseOrValue<string> | null,
      reserve?: PromiseOrValue<string> | null,
      amount?: null,
      to?: PromiseOrValue<string> | null
    ): WithdrawEventFilter;
  };

  estimateGas: {
    auction(
      nftAsset: PromiseOrValue<string>,
      nftTokenId: PromiseOrValue<BigNumberish>,
      bidPrice: PromiseOrValue<BigNumberish>,
      onBehalfOf: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    batchBorrow(
      assets: PromiseOrValue<string>[],
      amounts: PromiseOrValue<BigNumberish>[],
      nftAssets: PromiseOrValue<string>[],
      nftTokenIds: PromiseOrValue<BigNumberish>[],
      onBehalfOf: PromiseOrValue<string>,
      referralCode: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    batchRepay(
      nftAssets: PromiseOrValue<string>[],
      nftTokenIds: PromiseOrValue<BigNumberish>[],
      amounts: PromiseOrValue<BigNumberish>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    borrow(
      asset: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      nftAsset: PromiseOrValue<string>,
      nftTokenId: PromiseOrValue<BigNumberish>,
      onBehalfOf: PromiseOrValue<string>,
      referralCode: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    deposit(
      asset: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      onBehalfOf: PromiseOrValue<string>,
      referralCode: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    finalizeTransfer(
      asset: PromiseOrValue<string>,
      from: PromiseOrValue<string>,
      to: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      balanceFromBefore: PromiseOrValue<BigNumberish>,
      balanceToBefore: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getAddressesProvider(overrides?: CallOverrides): Promise<BigNumber>;

    getMaxNumberOfNfts(overrides?: CallOverrides): Promise<BigNumber>;

    getMaxNumberOfReserves(overrides?: CallOverrides): Promise<BigNumber>;

    getNftAuctionData(
      nftAsset: PromiseOrValue<string>,
      nftTokenId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getNftCollateralData(
      nftAsset: PromiseOrValue<string>,
      reserveAsset: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getNftConfiguration(
      asset: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getNftData(
      asset: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getNftDebtData(
      nftAsset: PromiseOrValue<string>,
      nftTokenId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getNftLiquidatePrice(
      nftAsset: PromiseOrValue<string>,
      nftTokenId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getNftsList(overrides?: CallOverrides): Promise<BigNumber>;

    getReserveConfiguration(
      asset: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getReserveData(
      asset: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getReserveNormalizedIncome(
      asset: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getReserveNormalizedVariableDebt(
      asset: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getReservesList(overrides?: CallOverrides): Promise<BigNumber>;

    initNft(
      asset: PromiseOrValue<string>,
      bNftAddress: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    initReserve(
      asset: PromiseOrValue<string>,
      bTokenAddress: PromiseOrValue<string>,
      debtTokenAddress: PromiseOrValue<string>,
      interestRateAddress: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    initialize(
      provider: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    liquidate(
      nftAsset: PromiseOrValue<string>,
      nftTokenId: PromiseOrValue<BigNumberish>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    onERC721Received(
      operator: PromiseOrValue<string>,
      from: PromiseOrValue<string>,
      tokenId: PromiseOrValue<BigNumberish>,
      data: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    paused(overrides?: CallOverrides): Promise<BigNumber>;

    redeem(
      nftAsset: PromiseOrValue<string>,
      nftTokenId: PromiseOrValue<BigNumberish>,
      amount: PromiseOrValue<BigNumberish>,
      bidFine: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    repay(
      nftAsset: PromiseOrValue<string>,
      nftTokenId: PromiseOrValue<BigNumberish>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    setMaxNumberOfNfts(
      val: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    setMaxNumberOfReserves(
      val: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    setNftConfiguration(
      asset: PromiseOrValue<string>,
      configuration: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    setPause(
      val: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    setReserveConfiguration(
      asset: PromiseOrValue<string>,
      configuration: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    setReserveInterestRateAddress(
      asset: PromiseOrValue<string>,
      rateAddress: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    withdraw(
      asset: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      to: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;
  };

  populateTransaction: {
    auction(
      nftAsset: PromiseOrValue<string>,
      nftTokenId: PromiseOrValue<BigNumberish>,
      bidPrice: PromiseOrValue<BigNumberish>,
      onBehalfOf: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    batchBorrow(
      assets: PromiseOrValue<string>[],
      amounts: PromiseOrValue<BigNumberish>[],
      nftAssets: PromiseOrValue<string>[],
      nftTokenIds: PromiseOrValue<BigNumberish>[],
      onBehalfOf: PromiseOrValue<string>,
      referralCode: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    batchRepay(
      nftAssets: PromiseOrValue<string>[],
      nftTokenIds: PromiseOrValue<BigNumberish>[],
      amounts: PromiseOrValue<BigNumberish>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    borrow(
      asset: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      nftAsset: PromiseOrValue<string>,
      nftTokenId: PromiseOrValue<BigNumberish>,
      onBehalfOf: PromiseOrValue<string>,
      referralCode: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    deposit(
      asset: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      onBehalfOf: PromiseOrValue<string>,
      referralCode: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    finalizeTransfer(
      asset: PromiseOrValue<string>,
      from: PromiseOrValue<string>,
      to: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      balanceFromBefore: PromiseOrValue<BigNumberish>,
      balanceToBefore: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getAddressesProvider(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getMaxNumberOfNfts(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getMaxNumberOfReserves(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getNftAuctionData(
      nftAsset: PromiseOrValue<string>,
      nftTokenId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getNftCollateralData(
      nftAsset: PromiseOrValue<string>,
      reserveAsset: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getNftConfiguration(
      asset: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getNftData(
      asset: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getNftDebtData(
      nftAsset: PromiseOrValue<string>,
      nftTokenId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getNftLiquidatePrice(
      nftAsset: PromiseOrValue<string>,
      nftTokenId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getNftsList(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    getReserveConfiguration(
      asset: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getReserveData(
      asset: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getReserveNormalizedIncome(
      asset: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getReserveNormalizedVariableDebt(
      asset: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getReservesList(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    initNft(
      asset: PromiseOrValue<string>,
      bNftAddress: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    initReserve(
      asset: PromiseOrValue<string>,
      bTokenAddress: PromiseOrValue<string>,
      debtTokenAddress: PromiseOrValue<string>,
      interestRateAddress: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    initialize(
      provider: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    liquidate(
      nftAsset: PromiseOrValue<string>,
      nftTokenId: PromiseOrValue<BigNumberish>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    onERC721Received(
      operator: PromiseOrValue<string>,
      from: PromiseOrValue<string>,
      tokenId: PromiseOrValue<BigNumberish>,
      data: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    paused(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    redeem(
      nftAsset: PromiseOrValue<string>,
      nftTokenId: PromiseOrValue<BigNumberish>,
      amount: PromiseOrValue<BigNumberish>,
      bidFine: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    repay(
      nftAsset: PromiseOrValue<string>,
      nftTokenId: PromiseOrValue<BigNumberish>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    setMaxNumberOfNfts(
      val: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    setMaxNumberOfReserves(
      val: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    setNftConfiguration(
      asset: PromiseOrValue<string>,
      configuration: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    setPause(
      val: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    setReserveConfiguration(
      asset: PromiseOrValue<string>,
      configuration: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    setReserveInterestRateAddress(
      asset: PromiseOrValue<string>,
      rateAddress: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    withdraw(
      asset: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      to: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;
  };
}
